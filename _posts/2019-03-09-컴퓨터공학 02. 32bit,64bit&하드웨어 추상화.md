---
layout: post
title:  "컴퓨터공학 02. 32bit,64bit&하드웨어 추상화"
date:   2019-03-09 01:06:23 +0700
categories: [컴퓨터공학]
---

### 2019.03.09 TIL

(TIL은 스스로 이해한 것을 바탕으로 정리한 것으로 오류가 있을 수 있습니다)

\# 질문에 답하기

1. 32비트 컴퓨터에는 램슬롯이 4기가 넘어가면 아예 인식을 못하게 된다. 왜 그럴까?

# 32bit / 64bit

원래 램은 없어도 된다. 바로 하드 or SSD와 cpu가 직접 연결되어 있어도 가능하다.

하지만 cpu의 작업 요청 속도와 하드 ,SSD에서 작업에 대해 응답해주는 속도가 너무나도 차이가 나기 때문에 그 중간자의 역활로 ram이 필요하게 되었다.

Ram은 random access memory를 줄인 말로 cpu가 요청할 것으로 예상 되는 자료들을 SSD 또는 하드에서 불러와 미리 저장소에 저장해 놓는다. 따라서 cpu가 어떤 자료를 요청했을 때 빠르게 반환시켜주고 만약에 그 자료가 ram에 올라와 있지 않다면 다시 램에서 SSD 혹은 저장소로 요청을 하게 된다. 우리는 이럴 때 랙이 걸린다고 표현한다.

<img width="528" alt="스크린샷 2019-04-06 오후 3 15 05" src="https://user-images.githubusercontent.com/46436843/55665675-dbe74080-587e-11e9-830d-0a3983bf43f9.png">

기본적으로 데이터의 이동은 메모리 게층 순차적으로 이루어져야 한다. 따라서 하드디스크에 있는 데이터는 메인 메모리를 거쳐 캐시 그리고 레지서트로 이동하게 된다. 하지만 여기에는 엄청난 속도의 차이가 존재한다. 
### cycles for data
* register
	* 1 cycle
* cache
	* 3 cycles
* memory
	* 20-100 cycles
* hard disk
	* 500000-5000000 cycles

위와 같이 각 데이터의 이동속도는 천차만별이다.


## 그럼 32bit와 64bit는 무엇일까?

32bit는 cpu에서 ram에 한번에 요청할 수 있는 데이터의 양이다.

컴퓨터는 0과 1로 표현할 수 있고 하나의 0과 1은 1bit를 표현한다. 따라서

32bit는 0000 0000 0000 0000 0000 0000 0000 0000 총 32자리의 bit를 표현할 수 있고

이것은 2의 32승이다. 

cpu는 최대 2의 32승 갯수의 특정 데이터를  ram에 요청할 수 있게 되는 것이다.

그럼 이제 다시 ram으로 가보자

SSD또는 하드에서 가져온 자료를 저장해놓는 메모리에서 특정 자료를 찾기 위해서는 메모리 주소가 필요하다. 이러한 메모리 주소는 1개당 1바이트를 가르킨다. (1바이트는 8비트이다) 즉 8비트로 메모리 1개의 주소를 명확하게 설정할 수 있다는 것이다. 

우리는  cpu에서 최대 2의 32승 bit로 2의 32승 개 만큼의 주소를 요청할 수 있고 메모리에서 주소 1개는 1바이트를 나타냄으로 ram은 2에 32승 바이트를 표현할 수 있다. (#이제 이게 의문이 들기 시작한다. 왜 주소 1개는 1바이트를 나타낼까?. 그렇게 표현하기로 결정했다. ) 2에 32승 바이트는 4,294,967,294바이트고 이는 4 x 1024 x 1024 x 1024 byte로 풀어 쓸 수 있고 byte - kbyte - mbyte - gbyte 등을 거쳐서 4G로 쓸 수 있다. 따라서 32bit 컴퓨터에서는 최대 4G 램까지 밖에 가르킬 수 없다.

32bit 컴퓨터에 8G램을 설치한다 하더라도 32bit가 요청할 수 있는 최대 램의 주소는 4G이므로 램의 나머지 부분들은 아예 주소를 배정받을 수도 없게 되는 것이다.

CPU가 램에 자료를 요청하는데 램의 공간이 아무리 넓어도 CPU가 요청할 수 있는 공간이 한정되어 있다면 의미가 없는 것이다.


# 하드웨어 추상화/ 언어 추상화


c 와 c++ 은 하이레벨 언어이다.

로우레벨은 어셈블리어 밖에 없다.

### ammembly lan만 로우레벨 언어이다.

1. 컴퓨터와 1:1로 대응해야 하므로 cpu각각의 이름을 다 알아야 한다. cpu에 있는 레지스터의 이름까지 다 알아야 쓸 수 있다.

2. 하드웨어 의존적 언어이다. cpu로 바뀌면 새롭게 다시 다 짜야 한다.

### high- level lan

- cpu , 즉 하드웨어를 몰라도 쓸 수 있게 되었다. 하드웨어 의존적이지 않아짐. 이것을 하드웨어 추상화라고 한다.
1. c언어 - 코드를 짜놓았으면 어떤 하드웨어에 상관없이 제조사가 제공하는 컴파일러를 통해 각 cpu에 작동하는 어셈블리어로 바꾸어 작동시킬 수 있다.
	* 하이레벨 언어 중에서 추상화가 가장 덜 된 케이스
	* int (내가 4바이트를 쓰겠다.) short(16byte를 쓰겠다.) 등등 아직 메모리와 바인딩이 되어 있음 

이후에 python,javascript 등으로 넘어오면 

* a = 10 일 때 메모리 차원에서 보다 바인딩이 떨어짐 . 언어 추상화가 더 잘 일어남.

하드웨어 추상화 계층(HAL, Hardware Abstraction Layer)은 컴퓨터의 물리적인 하드웨어와 컴퓨터에서 실행되는 소프트웨어 사이의 추상화 계층이다. 이것은 하드웨어(cpu)의 차이를 숨겨서 응용 프로그램이 작동할 수 있는 일관된 플랫폼을 제공한다.


## 아직은 이해 안되는 참고사항

char --> 1byte이다. 0 ~ 2** 8/ 2 0 ~ 255 ---> -128 ~ 127 까지 사용가능

4byte ---? 2 ** 32 / 0 ~

컴파일러 언어를 한개씩은 한다. 컴파일러 언어가 뭔가?

c 언어 (integer overflow) --->

char num = 126; char의 범위가 범위가 -128 ~ 127까지 인데 그 수를 넘어가므로 overflow가 일어난다.

num ++; num ++;

if (num>0) { print("%d \n" , num); } else { print("wrong1"); }