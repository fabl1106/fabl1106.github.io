---
layout: post
title:  "컴퓨터공학 07. CPU"
description: "컴퓨터공학 CPU란? CPU의 구조, 특징"
author: Byeonguk Kim
date:   2019-03-15 01:06:23 +0700
categories: [컴퓨터공학]
---

### 2019.03.15 TIL

(TIL은 스스로 이해한 것을 바탕으로 정리한 것으로 오류가 있을 수 있습니다)

\# 질문에 답하기.    
1. C = a+b 라고 할때 cpu와 메모리 상에서는 무슨 할일이 많길래 3줄이나 필요한가?  
2. 메모리에서 어떻게 cpu로 가지고와서 실행되는가?
3. CPU의 구조에 대해 설명해봐라

# CPU

## 1.CPU의 구조

<img width="497" alt="1" src="https://user-images.githubusercontent.com/46436843/54499878-16ce1680-495a-11e9-8b04-99f95a64df2e.png">

\# 사진은 컴퓨터사이언스 부트캠프 with 파이썬에서 가지고 왔습니다
[출처](https://thebook.io/006950/ch08/02/01/)

1. CU(Control unit)
	* 기계어를 어떤 명령인지 해석하고 이를 실행하려고 할 때 CPU의 각 파트에 지시를 내리는 역할 	
2. ALU(Arithmetic Logic Unit)
	* 덧셈, 뺼셈등의 산술연산과 AND, OR와 같은 논리 연산 진행
3. AX,BX,IR,PC(레지스터)
	* CPU안의 내장된 메모리
	* AX(Accumulator)
		* 값을 축적해가는 레지스터
 
 
#### CPU의 원리를 알기 위해 조합 논리 회로와 순차 논리 회로를 이해하면 CPU의 원리를 정확하게 이해 할 수 있다. 

### 조합 논리 회로
* 현재 입력에 의해서만 출력이 결정되는 논리 회로
* 가산기(ALU안에 있음)

<img width="590" alt="스크린샷 2019-03-18 오전 9 00 41" src="https://user-images.githubusercontent.com/46436843/54500093-657cb000-495c-11e9-8f25-b3e174bcac23.png">
\# 사진은 컴퓨터사이언스 부트캠프 with 파이썬에서 가지고 왔습니다
[출처](https://thebook.io/006950/ch08/02/01/)

* 덧셈이나 뺄셈등을 포함한 ALU(산술 논리 장치) 연산은 현재 출력이 오로지 현재 입력에 의해서만 결정된다. 이는 조합 논리 회로의 특징이다.

### 순차 논리 회로
\# 미리 알면 좋은 플립플롭.  
플립플롭 또는 래치(영어: flip-flop 또는 latch)는 전자공학에서 1 비트의 정보를 보관, 유지할 수 있는 회로이며 순차 회로의 기본요소이다. 조합논리회로에 비해 플립플롭은 이전상태를 계속 유지하여 저장한다.

* 현재의 출력이 현재의 입력과 과거의 출력에 따라 정해지는 논리 회로
* AND, OR , NAND, NOR과 같이 과거의 출력이 현재의 입력과 합쳐져서 현재의 출력이 결정되는 논리 회로
* 입력이 바뀌었다고 해서 출력이 바로 바뀌는 것이 아니라 특정 상황이 되었을때만 바뀐다는 점, 이를 통해 이전 출력 값이 유지 된다는 것이다. 
* 유지 된다는 것은 곧 저장된다고 할 수 있다.
* 이를 통해 순차 논리 회로를 구성하는 플립플롭을 메모리 소자, 즉 메모리를 구성하는 기본 단위라고 부르며, 실제로 레지스터는 플립플롭의 묶음이다.

#### 조합 논리 회로와 순차 논리 회로를 통해 알 수 있는 것은 ALU에서 조합 논리와 순차 논리가 계산이 되며, 조합 논리 회로를 나타내는 가산기는 ALU내부에 존재하며 AX, BX와 같은 레지스터는 순차 논리 회로를 계산하여 ALU내부로 보내 가산기로 계산한다?? ---> 이거는 선생님께 추가 질문해봐야겠다.

## 2. 클록
CPU의 속도를 나타내기 위해 2.6GHZ와 같은 단위를 이용한다.   
HZ는 주파수(진동수)를 나타내는 단위로 1초 동안 왕복하는 횟수를 나타낸다.      
2.6GHZ는 1초 동안 2.6 x 1024(g) x 1024(m) x 1024(k) x hz 만큼 왕복했는 것이며 이를 주기로 나타내면 1번 왕복하는데 걸리는 시간을 알 수 있다.   
이를 클록이라고 한다. 즉 1초에 몇번의 신호를 생성하는가 이다.  
보통 요즘 컴퓨터의 cpu가 2.0GHZ의 속도는 나타내고 있으므로 1회당 약 20억번의 클록 펄스를 생성한다.  
그리고 그 클록 펄스(신호)가 생성될 떄 마다 인스트럭션을 실행한다. 인스트럭션이란 우리가 작성한 코드가 cpu에서 실행되기 위해 최종적으로 변환된 기계어이다.   
또한 이 클록과 인스트럭션을 활용하여 성능을 나타내는 지수로 CPI(Clock per Instruction)이라는 것을 쓰기도 한다. 이는 인스트럭션당 클럭의 수를 나타낸다. 즉 한 인스트럭션이 실행될 때 얼마나의 클럭이 필요하냐를 나타낸다.

## 3. 시스템 버스

<img width="617" alt="스크린샷 2019-03-18 오전 10 19 23" src="https://user-images.githubusercontent.com/46436843/54501230-5f400100-4967-11e9-8b2a-7fef9d3dc33f.png">
\# 사진은 컴퓨터사이언스 부트캠프 with 파이썬에서 가지고 왔습니다
[출처](https://thebook.io/006950/ch08/02/01/)

시스템 버스를 설명하기 위해서는 먼저 각 레지스터의 이미부터 파악해야 한다.   

1. IR(instruction Register)  
	* 변환된 명령어는 프로그램을 실행하면 메인 메모리에 올려지고 하나씩 실행되는데 이때 메모리에 있는 명령으로 CPU로 가져와 저장해 두는 곳

2. PC(Program counter)
	* 현재 실행 중인 명령어 다음에 실행될 명령어의 메모리 주소를 담고 있는 곳

3. AX, BX(범용레지스터)
	* 주로 메모리에서 읽어 들인 데이터를 저장했다가 ALU가 연산할 때 피 연산자로 전달하거나 연산 결과 값을 저장할 때 쓰임

<img width="634" alt="스크린샷 2019-03-18 오전 10 31 33" src="https://user-images.githubusercontent.com/46436843/54501510-11c49380-4969-11e9-8b8d-3b728583d9b5.png">

\# 사진은 컴퓨터사이언스 부트캠프 with 파이썬에서 가지고 왔습니다
[출처](https://thebook.io/006950/ch08/02/01/)

### 시스템 버스
---------------
1. 데이터 버스(Data Bus)
	* 제어 버스의 신호에 따라 데이터를 CPU에서 메모리 전송하거나 반대로 메모리에서 CPU로 전송
2. 제어버스(Control Bus)
	* 데이터를 레지스터로 읽어볼지(READ) 아니면 메모리에 쓸지(Write) CPU가 메모리에 전달

3. 주소버스 (Address Bus)
	* 메모리에서 레지스터로 혹은 레지스터에서 메모리로 데이터를 전송할 때 필요한 메모리 주소를 전달

#### 결국 메모리에 저장된 정보를 어떻게 CPU로 가지고 와서 실행할 것인가에 대해 알아가는 것이다!!. 그럼 추가적으로 우리가 컴퓨터에 입력하는 정보들이 어떻게 메모리에 저장되며 그 저장된 정보를 CPU로 가지고 오는 것은 어떻게 이루어 지는 것인가?

IR에는 현재 실행 중인 명령어가 들어가 있고 이후에는 다시 메모리에서 IR로 명령어를 가지고 와야한다. 이를 FETCH(패치)라고 한다.   
이 패치를 하기 위해서 CU에서 제어버스를 통해 메모리에 READ 모드를 전달하고  
PC에 담겨져 있는 정보를 주소버스를 통해 메모리에 전달하고 그 주소를 바타으로    
데이터 버스를 통해 IR로 전달한다. 이 일련의 과정을 크게 패치라고 한다. 

## 4. 인스트럭션 세트

* Instruction set이란 CPU로 인식하여 실행할 수 있는 기계어이다.
* 기본 디자인
	* 1바이트
	* 덧셈 & 뺼셈
		* 3bit(명령어) + 2bit (reg1) + 2bit(reg2) + 1byte
	* 곱셈 & 나눗셈
		* 3bit(명령어) + 2bit (reg1) ---> 이미 AX에 있는 값에 명렁어 + reg1을 하여 다시 AX로 이동
	* 메모리 접근 명령어
		* 3bit(명령어) + 2bit (reg1/ 메모리를 저장할 위치) + 3bit(데이터가 저장된 메모리 위치-- 직접 및 간접 접근 명령어로 나뉨)

**이것을 통해 메모리에 저장된 기계어의 형태를 알아보고 CPU로 어떻게 불러오는지를 알 수 있다. 이제 메모리를 통해 우리가 입력한 정보가 어떻게 메모리에 저장되는지 공부한다**  
