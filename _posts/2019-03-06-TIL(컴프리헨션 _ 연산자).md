---
layout: post
title:  "2019_03_06_TIL(컴프리헨션 & 연산자)"
date:   2019-03-06 21:06:23 +0700
categories: [python]
---

###2019.03.06 TIL

(TIL은 스스로 이해한 것을 바탕으로 정리한 것으로 오류가 있을 수 있습니다)

## 컴프리헨션 & 연산자

========================

대답해보기

* 컴프리헨션이란?
* 연산자의 종류 및 각각 간단하게 이야기해보라

어제 복습을 덜 한 슬픔을 뒤로 하고 공부했던 것들을 조금 더 정리해보고자 한다.

## 오늘의 보너스

- 프로그램에서 a = 1 은 할당이고 a == 1 이 같다는 표현이다.

- 파이썬에서의 False

    -False / None / "" / [] / {} / set()



# 컴프리헨션

**컴프리헨션은 하나 이상의 이터레이터(iterater 반복적으로 하나씩 나올 수 있는 객체[list, string, dic. set, tuple 등]로 부터 파이썬의 자료구조를 만드는 컴팩트한 방법이다.**

### 리스트컴프리헨션

li = [i for i in range(1, 10)]  ---> 1부터 10전까지의 i로 리스트 만들기


### 딕셔너리 컴프리헨션
원래 딕셔너리 만들기 위해서는 아래와 같이 만들 수 있다.

```python3
>>>	tu = (("a",1), ("b",2))
>>>	dic = {}
>>>	for k,v in tu:
>>>		dic[k] = v
>>>	#위와 같이 만들 수 있다. 하지만 컴프리헨션을 이용하면 한 문장으로 만들 수 있다. 
>>> 
>>>	dic = {key:value for key, value in tu} 
```
하지만 컴프리헨션을 통해 한 문장으로 딕셔너리를 만들 수 있다.

# 오퍼레이터(연산자)

## bit 연산자

<img width="362" alt="연산자" src="https://user-images.githubusercontent.com/46436843/55286320-20816080-53d5-11e9-94c5-0d702c98a29c.png">

위의 진리표에 따라 비트 단위로 2진법 비교

1. bin(0b1010 & 0b1100) --- > 0b1000  그리고

2. bin(0b1010 | 0b1100) ---> 0b1110  또는 

3. bin(0b1010 ^ 0b1100) ---> 0b110 이거는 공부 더 필요할 듯 

   EXCLUSIVE OR 단독이다. 하늘아래 나만 존재 할 수 있다.

bit 연산자는 게임 인벤토리등을 구성할 때 쓸 수 있다.



## shift 연산자

프로그래밍 할 때 2의 배수로 나오면 성능이 더 좋다? 이게 맞는 말인가?  
실제로 맞는 말이다. shift operator로 인해 성능이 더 좋음

알고리즘에서 2의 배수로 가는 경우 shift 연산자를 직접 써주면 성능이 더 좋아진다.



1<<1 ---> 1은 0001 이고 <<1은 1을 왼쪽으로 한칸 민다는 것이다. 

답은 2

1<<2 ---> 1을 왼쪽으로 2칸 밀게 되므로 0100 답은 4

1<<3 ---> 1을 왼쪽으로 3칸 밀게 되므로 1000 답은 8



10>>1 ---> 10은 2진법으로 하면 1010 이므로 이걸 오른쪽으로 1칸 밀면 101이 된다 답은 5



## 논리 연산자 (logical operation)

논리 연산자는 진리표를 보고 참고하면 되고, 몇가지 예시를 들어보려고 한다.

1. [1,2] or [] ----> [1,2]

2. [1,2] and [] ---> []

3. [1,2] or [3,4] ---> [1,2]

4. [1,2] and [3,4] ---> [3,4]

5. [] and [1,2] ---> []

6. [] or [1,2] ---> [1,2]

#### 여기서 규칙은 제일 마지막에 참조한 객체를 반환이다.

1. [1,2] or [] ----> [1,2]      ㅡㅡ [1,2] 가 참이므로 더 이상 보지 않고 반환

2. [1,2] and [] ---> []  ㅡㅡ and 이므로 2번까지 봐야하고 []가 마지막으로 참조한 객체이므로 [] 반환
3. [1,2] or [3,4] ---> [1,2] ㅡㅡ or이라 [1,2]가 참이므로 더 이상 보지 않고 반환

4. [1,2] and [3,4] ---> [3,4] ㅡㅡ and 이므로 [3,4]까지 봐야하고 [3,4] 반환

5. [] and [1,2] ---> [] ㅡㅡ and인데 처음부터 false 이므로 더 이상 보지 않고 [] 반환

6. [] or [1,2] ---> [1,2] ㅡㅡ or이므로 두 번째까지 확인하고 [1,2] 반환



## 산술연산자(모듈러)

산술연산자는

+ : 더하기

- : 뺴기

/ : 나누기 (실수형 나누기)

/ : 몫의 정수 부분만 표현 (정수형 나누기)

* : 곱하기

** : 2 ** 50 ---> 2에 50승 (보통 math.pow(2, 50) 으로 쓴다.)

% : 8 % 3 ---> 8을 3으로 나눈 나머지 표현

+= / -= / *= / **= 도 쓸 수 있음









